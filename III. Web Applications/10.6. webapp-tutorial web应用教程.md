10.6 webapp-tutorial web应用教程
========================

本文是一篇循序渐进介绍用 Apache Shiro 保护 web 应用程序的教程。 它假定读者已经具备了 Shiro 的入门知识,并假设至少熟悉以下两个介绍性文档:

* [Application Security with Apache Shiro](http://www.infoq.com/articles/apache-shiro)
* [Apache Shiro 10 Minute Tutorial](http://shiro.apache.org/10-minute-tutorial.html)

学习本教程应该需要45分钟到1个小时时间。 当你完成后,你将有一个很好的关于 Shiro 是如何在一个 web 应用程序的概念。

目录

Overview
Project Setup
Step 1: Enable Shiro
Step 2: Connect to a User Store
Step 3: Enable Login and Logout
Step 4: User-Specific UI Changes
Step 5: Allow Access to Only Authenticated Users
Step 6: Role-based Access Control
Step 7: Permission-based Access Control

##Overview 概述
虽然 Apache Shiro 的核心设计目标允许它被用于任何基于 java 的应用程序的安全,如命令行应用程序、服务器守护进程 ,web 应用程序,等等,本指南将专注于最常见的用例:确保 web 应用程序安全运行在一个 servlet 容器,例如 Tomcat 或 Jetty。

###Prerequisites 先决条件

以下工具将被安装在本地开发机器为了跟随本教程。

* Git(测试版 w/1.7)
* Java SDK 7
* Maven 3
* 你最喜欢的IDE,比如 IntelliJ IDEA 或 Eclipse ,甚至一个简单的文本编辑器用于查看文件和更改。

###Tutorial Format 教程格式

这是一个循序渐进的教程。 本教程,和它的所有步骤,存在Git存储库。 当你复制 git 存储库, master 分支是你的起点。 在教程的每一步都是一个独立的分支。 你可以跟随只需查看 git 分支反映本教程一步你审查

###The Application 应用程序

我们将构建的 web 应用程序是一个超级网络应用,可以作为一个起点为您自己的应用程序。 它将展示用户登录,注销,特定于用户的欢迎消息,访问控制web 应用程序的某些部分,plugglable 安全数据存储和集成。

我们将开始通过建立项目,包括构建工具和声明依赖性,以及配置 servlet的 web.xml 文件启动 web 应用程序和 Shiro 的环境。

一旦我们完成设置,我们将层的各个部分的功能,包括集成的安全数据存储,然后让用户登录,注销,访问控制。

##Project Setup项目设置

不必手动设置一个目录结构和初始基本文件,我们已为你这样做好了一个 git 存储库。

###1. Fork the tutorial project 先fork本教程项目

在 github，浏览[ tutorial project ](https://github.com/lhazlewood/apache-shiro-tutorial-webapp) 项目,点击 Fork 按钮

###2. Clone your tutorial repository 复制教程存储库

现在您已经将项目 fork 在你的 GitHub 帐户,克隆它在本地机器上:

>$ git clone git@github.com:$YOUR_GITHUB_USERNAME/apache-shiro-tutorial-webapp.git    

(其中 $YOUR_GITHUB_USERNAME 是你的 GitHub 用户名)


用 cd 进入本地的项目目录查看项目结构:

>$ cd apache-shiro-tutorial-webapp

###3. Review project structure 审查项目结构

当前项目结构为：

	apache-shiro-tutorial-webapp/
	  |-- src/
	  |  |-- main/
	  |    |-- resources/
	  |      |-- logback.xml
	  |    |-- webapp/
	  |      |-- WEB-INF/
	  |        |-- web.xml
	  |      |-- home.jsp
	  |      |-- include.jsp
	  |      |-- index.jsp
	  |-- .gitignore
	  |-- .travis.yml
	  |-- LICENSE
	  |-- README.md
	  |-- pom.xml

解释下：

* pom.xml :Maven 项目/构建文件。 它有Jetty 配置,这样你就可以马上运行 mvn jetty:run 测试您的 web 应用程序运行。
* README.md :一个简单的项目的自述文件
* LICENSE :该项目是 Apache 2.0 许可协议
* .travis.yml :一个 [Travis CI](https://travis-ci.org/) 配置文件以确保它总是在项目构建时，持续运行集成构建您的项目。
* .gitignore :一个 git 忽略文件,包含的后缀和目录是那些不应该纳入到版本控制中。
* src/main/resources/logback.xml:一个简单的 [Logback](http://logback.qos.ch/) 配置文件。 对于本教程,我们选择 [SLF4J](http://www.slf4j.org/) 的日志 API 和 Logback 日志的实现。 这可能很容易被熟悉 Log4J 或者 JUL 的人所接受。
* src/main/webapp/WEB-INF/web.xml :最初的 web.xml 文件,我们将配置很快使用Shiro。
* src/main/webapp/include.jsp :一个页面,其中包含常见的引入和声明,包括其他的JSP页面。 这让我们在一个地方来管理引入和声明。
* src/main/webapp/home.jsp :应用的简单的默认主页。 包括 include.jsp (如将其他人,因为我们很快就会看到)。
* src/main/webapp/index.jsp :默认站点索引页面-这仅仅是将请求转发给我们 home.jsp 主页。

###4. Run the webapp 运行

运行

>$ mvn jetty:run 

打开浏览器访问 [localhost:8080](http://localhost:8080/),页面将会输出 Hello, World! 

按`ctl-C` (或者 mac 中的 `cmd-C`) 来关闭应用

##Step 1: Enable Shiro 启动 shiro

我们最初的 master 库 只是一个简单的通用的 web 应用程序,可以作为任何应用程序的模板。 让我们添加的最低限度,启动 Shiro web 应用程序。

执行以下git checkout 命令加载 Step1 分支:

>$ git checkout step1

检出的分支，有两点变化

1. 添加了一个 src/main/webapp/WEB-INF/shiro.ini 文件
2. src/main/webapp/WEB-INF/web.xml 改变了.

###1a: Add a shiro.ini file

可以配置 Shiro 在许多不同的方式在一个web应用程序,这取决于您所使用的web和/或MVC框架。 例如,您可以通过Spring配置Shiro,Guice,Tapestry,和许多更多。

为了简单起见,我们将启动一个 Shiro 环境使用Shiro的默认值(非常简单的) INI [配置](https://github.com/waylau/apache-shiro-1.2.x-reference/blob/master/I.%20Overview%20%E6%80%BB%E8%A7%88/4.%20Configuration%20%E9%85%8D%E7%BD%AE.md) 。

如果你签出 Step1 分支,您将看到这个新的的内容 src/main/webapp/WEB-INF/shiro.ini 文件(简短标题删除注释):
	
	[main]
	
	# Let's use some in-memory caching to reduce the number of runtime lookups against Stormpath.
	# A real application might want to use a more robust caching solution (e.g. ehcache or a
	# distributed cache).  When using such caches, be aware of your cache TTL settings: too high
	# a TTL and the cache won't reflect any potential changes in Stormpath fast enough.  Too low
	# and the cache could evict too often, reducing performance.
	cacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager
	securityManager.cacheManager = $cacheManager

 ini 包含一个简单的  [main] 和一些最小的配置:

* 它定义了一个新的 cacheManager (缓存管理器) 实例。 缓存是Shiro的体系结构的一个重要组成部分,它减少了不断往返通信各种数据存储。 这个示例使用 MemoryConstrainedCacheManager 这是唯一真正好的单个JVM 的应用程序。 如果您的应用程序部署在多个主机(如集群网络服务器),您需要使用集群缓存管理器实现。
* 在Shiro securityManager 它配置新  cacheManager (缓存管理器)  的实例  。 一个Shiro SecurityManager 实例总是存在的,所以它不需要显式地定义。

###1b: Enable Shiro in web.xml

当我们有一个 shiro.ini 配置,我们需要加载它,并开始一个新的 Shiro 环境和使 web 应用程序环境的实现。

我们所做的这一切通过添加现有的几件事到 src/main/webapp/WEB-INF/web.xml 文件:

	<listener>
	    <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
	</listener>
	
	<filter>
	    <filter-name>ShiroFilter</filter-name>
	    <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
	</filter>
	
	<filter-mapping>
	    <filter-name>ShiroFilter</filter-name>
	    <url-pattern>/*</url-pattern>
	    <dispatcher>REQUEST</dispatcher>
	    <dispatcher>FORWARD</dispatcher>
	    <dispatcher>INCLUDE</dispatcher>
	    <dispatcher>ERROR</dispatcher>
	</filter-mapping>

###1c: Run the webapp

当检出 step1 分支，运行

>$ mvn jetty:run

这一次,你会看到日志输出类似于以下,表明 Shiro 确实是运行在你的应用:

	16:04:19.807 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Starting Shiro environment initialization.
	16:04:19.904 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Shiro environment initialized in 95 ms.

按`ctl-C` (或者 mac 中的 `cmd-C`) 来关闭应用

##Step 2: Connect to a User Store 连接用户存储

检出 step2 分支

>$ git checkout step2

现在我们已经在 webapp 中集成和运行了 Shiro。 但是我们还没有真正告诉 Shiro 做任何事!

之前我们可以登录,注销,或执行基于角色或基于许可的访问控制,或任何其他安全相关的,我们需要用户!

我们需要配置 Shiro 访问 用户存储 的一些类型的,所以它可以查找用户执行登录尝试,或检查角色的安全决策,等等。有许多类型的用户存储任何应用程序可能需要访问:也许你在 MySQL 数据库中存储用户,也许在MongoDB,也许你的公司将用户帐户存储在 LDAP 或 Active Directory,也许你将它们存储在一个简单的文件,或其他专有数据存储。

Shiro 通过所谓的 Realm 来实现这些。 Shiro 的文档:

>Reamls 是 Shiro 和你的程序安全数据之间的“桥”或者“连接”，它用来实际和安全相关的数据如用户执行身份认证（登录）的帐号和授权（访问控制）进行交互，Shiro 从一个或多个程序配置的 Realm 中查找这些东西。 Realm 本质上是一个特定的安全 DAO：它封装与数据源连接的细节，得到Shiro 所需的相关的数据。在配置 Shiro 的时候，你必须指定至少一个Realm 来实现认证（authentication）和/或授权（authorization）。SecurityManager 可以配置多个复杂的 Realm，但是至少有一个是需要的。 Shiro 提供开箱即用的 Realms 来连接安全数据源（或叫地址）如 LDAP、JDBC、文件配置如INI和属性文件等，如果已有的Realm不能满足你的需求你也可以开发自己的Realm实现。 和其它内部组件一样，Shiro SecurityManager 管理如何使用 Realms获取 Subject 实例所代表的安全和身份信息。(*译者注*：详见[说明文档](https://github.com/waylau/apache-shiro-1.2.x-reference/blob/master/II.%20Core%20%E6%A0%B8%E5%BF%83/7.%20Realms.md))

因此,我们需要配置一个领域,那么我们可以访问用户。

###2a: Set up Stormpath

本教程的精神是保持尽可能简单,不引入复杂性或范围干扰了我们的学习Shiro 的目的,我们将使用一个简单的 realm : Stormpath realm。

[Stormpath](http://stormpath.com/) 云托管用户管理服务,以完全自由发展为目的。 这意味着启用 Stormpath 之后,你已经准备好如下:

* 一个用户界面来管理应用程序,目录,帐户和组。 Shiro 不提供这个,所以通过本教程这将是方便和节省你的时间。
* 一个安全的存储用户密码的机制。 您的应用程序不需要担心密码安全、密码比较或存储密码。 虽然 Shiro 可以做这些事情,你必须配置它们,知道密码的概念。 Stormpath 自动化密码安全所以你(Shiro)不需要担心如何“步入正轨”。
* 过电子邮件帐户电子邮件验证和密码重置的安全工作流通。 Shiro不支持这个,因为它通常是特定于应用程序的。
* 主持/管理”always on“基础设施——你不需要设置任何或维持任何东西。

对于本教程,Stormpath 比建立一个独立的 RDBMS 服务器还有担心 SQL 或密码加密问题等等简单的多了。 所以我们将使用它。

当然,Stormpath 只是许多 Shiro 可以连接的后端数据存储之一。 我们将讨论更复杂的数据存储和特定于应用程序的配置之后。

####Sign up for Stormpath 注册

1. 填写 [Stormpath 注册表单](https://api.stormpath.com/register), 它会发邮件确认
2. 确认邮件

####Get a Stormpath API Key 获取API Key

Stormpath API 所需的关键是 Stormpath Realm 用来与 Stormpath 交流。 获得 Stormpath API Key:

1. 登录到 [Stormpath 管理控制台](https://api.stormpath.com/) 使用你的Stormpath 注册使用的电子邮件地址和密码
2. 在结果页面的右上角,访问 Settings > My Account 。
3. 在账户信息页面, Security Credentials, 点击  Create API Key 。

这将生成 API Key 并下载到你的电脑 apiKey.properties 文件。 如果你在文本编辑器中打开文件,您将看到类似于下面的:

	apiKey.id = 144JVZINOF5EBNCMG9EXAMPLE
	apiKey.secret = lWxOiKqKPNwJmSldbiSkEbkNjgh2uRSNAb+AEXAMPLE

将该文件保存在一个安全的位置,比如在一个隐藏您的主目录 .stormpath 目录中。 例如:

	$HOME/.stormpath/apiKey.properties
	
还改变文件权限,以确保只有你能读这个文件。 例如,在 *nix 操作系统:

	$ chmod go-rwx $HOME/.stormpath/apiKey.properties

####Register the web application with Stormpath 注册web应用

我们必须通过 Stormpath 注册我们的 web 应用程序，用于用户的管理和身份验证。简单通过REST请求, POST 到一个新的 Stormpath 应用程序资源 URL:

	curl -X POST --user $YOUR_API_KEY_ID:$YOUR_API_KEY_SECRET \
	    -H "Accept: application/json" \
	    -H "Content-Type: application/json" \
	    -d '{
	           "name" : "Apache Shiro Tutorial Webapp"
	        }' \
	    'https://api.stormpath.com/v1/applications?createDirectory=true'

其中

* $YOUR_API_KEY_ID 是 apiKey.properties 文件中 apiKey.id 值
* YOUR_API_KEY_SECRET 是 apiKey.properties 文件中 apiKey.secret 值

那样就将会创建你的应用， 下面是一个响应示例：

	{
	    "href": "https://api.stormpath.com/v1/applications/aLoNGrAnDoMAppIdHeRe",
	    "name": "Apache Shiro Tutorial Webapp",
	    "description": null,
	    "status": "ENABLED",
	    "tenant": {
	        "href": "https://api.stormpath.com/v1/tenants/sOmELoNgRaNDoMIdHeRe"
	    },
	    "accounts": {
	        "href": "https://api.stormpath.com/v1/applications/aLoNGrAnDoMAppIdHeRe/accounts"
	    },
	    "groups": {
	        "href": "https://api.stormpath.com/v1/applications/aLoNGrAnDoMAppIdHeRe/groups"
	    },
	    "loginAttempts": {
	        "href": "https://api.stormpath.com/v1/applications/aLoNGrAnDoMAppIdHeR/loginAttempts"
	    },
	    "passwordResetTokens": {
	        "href": "https://api.stormpath.com/v1/applications/aLoNGrAnDoMAppIdHeRe/passwordResetTokens"
	    } 
	}

注意顶层的 href ,如 https://api.stormpath.com/v1/applications/$YOUR_APPLICATION_ID ，接下来我们将在 shiro.ini 配置使用这个 href 。

####Create an application test user account 创建应用测试用户账号

现在有了应用，我们要创建一个简单的测试用户

	curl -X POST --user $YOUR_API_KEY_ID:$YOUR_API_KEY_SECRET \
	    -H "Accept: application/json" \
	    -H "Content-Type: application/json" \
	    -d '{
	           "givenName": "Jean-Luc",
	           "surname": "Picard",
	           "username": "jlpicard",
	           "email": "capt@enterprise.com",
	           "password":"Changeme1"
	        }' \
	 "https://api.stormpath.com/v1/applications/$YOUR_APPLICATION_ID/accounts"

同样的，不要忘了修改 $YOUR_APPLICATION_ID

###2b: Configure the Realm in shiro.ini 配置

一旦你选择至少一个用户连接存储,我们将需要配置一个 Realm 来表示数据存储,然后告诉 Shiro SecurityManager 。

如果你已经签出了 step2 分支,你会注意到的 shiro.ini 文件的 (主要) 现在部分有以下补充:
	
	# 配置 Realm 来连接用户存储.本教程只简单的指向 Stormpath
	# 花 5 分钟进行设置:
	stormpathClient = com.stormpath.shiro.client.ClientFactory
	stormpathClient.cacheManager = $cacheManager
	stormpathClient.apiKeyFileLocation = $HOME/.stormpath/apiKey.properties
	stormpathRealm = com.stormpath.shiro.realm.ApplicationRealm
	stormpathRealm.client = $stormpathClient
	
	# 找到这个 你在Stormpath 创建应用时的 URL :
	# Applications -> (choose application name) --> Details --> REST URL
	stormpathRealm.applicationRestUrl = https://api.stormpath.com/v1/applications/$STORMPATH_APPLICATION_ID
	stormpathRealm.groupRoleResolver.modeNames = name
	securityManager.realm = $stormpathRealm

做以下修改:

* 改变 $ HOME 占位符实际主目录路径,例如 /home/jsmith 所以最后 stormpathClient.apiKeyFileLocation 值是类似 /home/jsmith/.stormpath/apiKey.properties 。 这条路必须匹配的位置 apiKey.properties 你在 Step 2a.中从Stormpath下载一个文件。

* 改变 step2 中 Stormpath 返回来的 href 中  $STORMPATH_APPLICATION_ID  占位符中的实际ID值。 最后的 stormpathRealm.applicationRestUrl 值应该类似 https://api.stormpath.com/v1/applications/6hsPwoRZ0hCk6ToytVxi4D (当然有不同的应用程序ID)。

###2c: Commit your changes 提交修改

替换 $ HOME 和 STORMPATH_APPLICATION_ID 值是特定于您的应用程序。 继续提交这些更改你的分支:

	$ git add . && git commit -m "updated app-specific placeholders" .

*译者注*：参考：[http://shiro.apache.org/webapp-tutorial.html](http://shiro.apache.org/webapp-tutorial.html)